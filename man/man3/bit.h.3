.TH "C/bit.h" 3 "Sun Feb 21 2021" "Bit Manipulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C/bit.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBBIT_MASK\fP(n)   \fBBIT_MASK_HELPER\fP(n, uint32_t)"
.br
.RI "Creates a UINT32 BITMASK of size n\&. "
.ti -1c
.RI "#define \fBBIT_SET_1\fP(var,  pos)   (var | (1 << pos))"
.br
.RI "Set a BIT on the variable at a given position\&. "
.ti -1c
.RI "#define \fBBIT_SET_N\fP(var,  start_pos,  n)   (var | (\fBBIT_MASK\fP(n) << start_pos))"
.br
.RI "Set N BITS on the variable starting from a given position\&. "
.ti -1c
.RI "#define \fBBIT_RESET_1\fP(var,  pos)   (var & ~(1 << pos))"
.br
.RI "Clear a BIT from the variable at a given position\&. "
.ti -1c
.RI "#define \fBBIT_RESET_N\fP(var,  start_pos,  n)   (var & ~(\fBBIT_MASK\fP(n) << start_pos))"
.br
.RI "Clear N BITS on the variable starting from a given position\&. "
.ti -1c
.RI "#define \fBBIT_READ_1\fP(var,  pos)   ((var >> pos) & 0x01)"
.br
.RI "Read a BIT var from the variable at a given position\&. "
.ti -1c
.RI "#define \fBBIT_READ_N\fP(var,  start_pos,  n)   ((var >> start_pos) & \fBBIT_MASK\fP(n))"
.br
.RI "Read N BIT vars from the variable starting from a given position\&. "
.ti -1c
.RI "#define \fBBIT_FLIP_1\fP(var,  pos)   (var ^ (1 << pos))"
.br
.RI "Flip a BIT at a given position\&. "
.ti -1c
.RI "#define \fBBIT_FLIP_N\fP(var,  start_pos,  n)   (var ^ (\fBBIT_MASK\fP(n) << start_pos))"
.br
.RI "Flip N BITS starting from a given position\&. "
.ti -1c
.RI "#define \fBBIT_MASK64\fP(n)   \fBBIT_MASK_HELPER\fP(n, uint64_t)"
.br
.RI "Creates a UINT64 BITMASK of size n\&. "
.ti -1c
.RI "#define \fBBIT_MASK_HELPER\fP(pos,  type)   (~((type)(~0) << pos))"
.br
.RI "A generic BIT MASK API for different datatypes\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define BIT_FLIP_1(var, pos)   (var ^ (1 << pos))"

.PP
Flip a BIT at a given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvar\fP The output variable that is modified 
.br
\fIpos\fP The position of the bit to flip (0 indexed) 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT32 
.RE
.PP

.SS "#define BIT_FLIP_N(var, start_pos, n)   (var ^ (\fBBIT_MASK\fP(n) << start_pos))"

.PP
Flip N BITS starting from a given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvar\fP The output variable that is modified 
.br
\fIstart_pos\fP The starting position of the bit to flip (0 indexed) 
.br
\fIn\fP Number of bits to flip 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT32 
.RE
.PP

.SS "#define BIT_MASK(n)   \fBBIT_MASK_HELPER\fP(n, uint32_t)"

.PP
Creates a UINT32 BITMASK of size n\&. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Numbers of bits used to create the BITMASK 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT32 
.RE
.PP

.SS "#define BIT_MASK64(n)   \fBBIT_MASK_HELPER\fP(n, uint64_t)"

.PP
Creates a UINT64 BITMASK of size n\&. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of bits used to create the BITMASK 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT64 
.RE
.PP

.SS "#define BIT_MASK_HELPER(pos, type)   (~((type)(~0) << pos))"

.PP
A generic BIT MASK API for different datatypes\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpos\fP Shift by current position 
.br
\fItype\fP Datatype used (uint32_t, uint64_t) 
.RE
.PP
\fBReturns:\fP
.RS 4
sizeof(type) 
.RE
.PP

.SS "#define BIT_READ_1(var, pos)   ((var >> pos) & 0x01)"

.PP
Read a BIT var from the variable at a given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvar\fP The input variable to read from 
.br
\fIpos\fP The position of the bit to read (0 indexed) 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT8 
.RE
.PP

.SS "#define BIT_READ_N(var, start_pos, n)   ((var >> start_pos) & \fBBIT_MASK\fP(n))"

.PP
Read N BIT vars from the variable starting from a given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvar\fP The input variable to read from 
.br
\fIstart_pos\fP The starting position of the bit to read (0 indexed) 
.br
\fIn\fP Number of bits to read 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT32 
.RE
.PP

.SS "#define BIT_RESET_1(var, pos)   (var & ~(1 << pos))"

.PP
Clear a BIT from the variable at a given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvar\fP This output variable that is modified 
.br
\fIpos\fP The BIT position to clear data (0 indexed) 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT32 
.RE
.PP

.SS "#define BIT_RESET_N(var, start_pos, n)   (var & ~(\fBBIT_MASK\fP(n) << start_pos))"

.PP
Clear N BITS on the variable starting from a given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvar\fP The output variable that is modified 
.br
\fIstart_pos\fP The starting position of the bit (0 indexed) 
.br
\fIn\fP The number of bits used 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT32 
.RE
.PP

.SS "#define BIT_SET_1(var, pos)   (var | (1 << pos))"

.PP
Set a BIT on the variable at a given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvar\fP The output variable that is modified 
.br
\fIpos\fP The BIT position to set data (0 indexed) 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT32 
.RE
.PP

.SS "#define BIT_SET_N(var, start_pos, n)   (var | (\fBBIT_MASK\fP(n) << start_pos))"

.PP
Set N BITS on the variable starting from a given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvar\fP The output variable that is modified 
.br
\fIstart_pos\fP The starting position of the bit (0 indexed) 
.br
\fIn\fP The number of bits used 
.RE
.PP
\fBReturns:\fP
.RS 4
UINT32 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Bit Manipulation from the source code\&.
